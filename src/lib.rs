//! Testing of Debug and Display format implementations with support for `no_std`.
//!
//! ## `std` vs `no_std`
//! This crate builds in `no_std` mode by default, allowing for testing of [`Debug`]
//! implementations. If you wish to test `Display` implementations, enable the `std` crate feature.

#![cfg_attr(not(feature = "std"), no_std)]
#![forbid(unsafe_code)]
#![deny(warnings, clippy::pedantic)]
#![warn(
    clippy::expect_used,
    clippy::missing_errors_doc,
    clippy::unwrap_used,
    missing_docs,
    rust_2018_idioms,
    rust_2021_compatibility,
    unused_qualifications
)]
// Enables the `doc_cfg` feature when the `docsrs` configuration attribute is defined.
#![cfg_attr(docsrs, feature(doc_cfg))]

use core::fmt::{Debug, Write};

/// Functionality for testing [`Debug`] or `Display` implementations.
pub struct AssertFormat<'a> {
    /// The original string to compare.
    original: &'a str,
    /// The remaining text to compare.
    remaining: &'a str,
}

impl<'a> AssertFormat<'a> {
    fn new(s: &'a str) -> Self {
        Self {
            original: s,
            remaining: s,
        }
    }
    /// Asserts that the `Display` trait is correctly implemented.
    ///
    /// ## Panics
    /// This call panics if the output generated by the `Display` implementation
    /// differs from the `expected` value.
    #[cfg(feature = "std")]
    pub fn assert_display_fmt<D>(instance: D, expected: &str)
    where
        D: std::fmt::Display,
    {
        let mut test = AssertFormat::new(expected);
        let _ = write!(&mut test, "{instance}");
    }

    /// Asserts that the `Debug` trait is correctly implemented.
    ///
    /// ## Panics
    /// This call panics if the output generated by the `Debug` implementation
    /// differs from the `expected` value.
    pub fn assert_debug_fmt<D>(instance: D, expected: &str)
    where
        D: Debug,
    {
        let mut test = AssertFormat::new(expected);
        let _ = write!(&mut test, "{instance:?}");
    }
}

impl<'a> Write for AssertFormat<'a> {
    fn write_str(&mut self, s: &str) -> core::fmt::Result {
        let _ = self.original;
        if self.remaining.starts_with(s) && self.remaining.len() >= s.len() {
            self.remaining = &self.remaining[s.len()..];
        } else {
            let position = self.original.len() - self.remaining.len();
            panic!(
                "assertion failed: Expected \"{}\" but found \"{}\" starting at position {}",
                self.original, s, position
            );
        }
        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    struct Test<'a>(&'a str, char, &'a str);

    impl<'a> Debug for Test<'a> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            f.write_str(self.0)?;
            f.write_char(self.1)?;
            f.write_str(self.2)
        }
    }

    #[cfg(feature = "std")]
    impl<'a> std::fmt::Display for Test<'a> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            f.write_str(self.0)?;
            f.write_char(self.1)?;
            f.write_str(self.2)
        }
    }

    #[test]
    pub fn debug() {
        let input = Test("valid", ' ', "input");
        AssertFormat::assert_debug_fmt(input, "valid input");
    }

    #[test]
    #[allow(clippy::should_panic_without_expect)]
    #[should_panic]
    pub fn debug_invalid() {
        let input = Test("valid", ' ', "inputs");
        AssertFormat::assert_debug_fmt(input, "valid input");
    }

    #[test]
    #[cfg(feature = "std")]
    pub fn display() {
        let input = Test("valid", ' ', "input");
        AssertFormat::assert_display_fmt(input, "valid input");
    }

    #[test]
    #[allow(clippy::should_panic_without_expect)]
    #[should_panic]
    #[cfg(feature = "std")]
    pub fn display_invalid() {
        let input = Test("valid", ' ', "inputs");
        AssertFormat::assert_display_fmt(input, "valid input");
    }
}
